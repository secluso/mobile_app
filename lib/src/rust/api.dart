// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `ensure_client_initialized`, `get_or_create_channel_mutex`, `lock_client`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `ClientKey`, `InitParams`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `clone`, `clone`, `eq`, `hash`

Future<bool> initializeCamera({
  required String cameraName,
  required String fileDir,
  required bool firstTime,
}) => RustLib.instance.api.crateApiInitializeCamera(
  cameraName: cameraName,
  fileDir: fileDir,
  firstTime: firstTime,
);

Future<void> deregisterCamera({required String cameraName}) =>
    RustLib.instance.api.crateApiDeregisterCamera(cameraName: cameraName);

Future<String> decryptVideo({
  required String cameraName,
  required String encFilename,
  required BigInt assumedEpoch,
}) => RustLib.instance.api.crateApiDecryptVideo(
  cameraName: cameraName,
  encFilename: encFilename,
  assumedEpoch: assumedEpoch,
);

Future<String> decryptThumbnail({
  required String cameraName,
  required String encFilename,
  required String pendingMetaDirectory,
  required BigInt assumedEpoch,
}) => RustLib.instance.api.crateApiDecryptThumbnail(
  cameraName: cameraName,
  encFilename: encFilename,
  pendingMetaDirectory: pendingMetaDirectory,
  assumedEpoch: assumedEpoch,
);

Future<String> flutterAddCamera({
  required String cameraName,
  required String ip,
  required List<int> secret,
  required bool standalone,
  required String ssid,
  required String password,
  required String pairingToken,
  required String credentialsFull,
}) => RustLib.instance.api.crateApiFlutterAddCamera(
  cameraName: cameraName,
  ip: ip,
  secret: secret,
  standalone: standalone,
  ssid: ssid,
  password: password,
  pairingToken: pairingToken,
  credentialsFull: credentialsFull,
);

Future<void> shutdownApp() => RustLib.instance.api.crateApiShutdownApp();

Future<bool> pingProprietaryDevice({required String cameraIp}) =>
    RustLib.instance.api.crateApiPingProprietaryDevice(cameraIp: cameraIp);

Future<Uint8List> encryptSettingsMessage({
  required String cameraName,
  required List<int> data,
}) => RustLib.instance.api.crateApiEncryptSettingsMessage(
  cameraName: cameraName,
  data: data,
);

Future<String> decryptMessage({
  required String clientTag,
  required String cameraName,
  required List<int> data,
}) => RustLib.instance.api.crateApiDecryptMessage(
  clientTag: clientTag,
  cameraName: cameraName,
  data: data,
);

Future<String> getGroupName({
  required String clientTag,
  required String cameraName,
}) => RustLib.instance.api.crateApiGetGroupName(
  clientTag: clientTag,
  cameraName: cameraName,
);

Future<bool> livestreamUpdate({
  required String cameraName,
  required List<int> msg,
}) => RustLib.instance.api.crateApiLivestreamUpdate(
  cameraName: cameraName,
  msg: msg,
);

Future<Uint8List> livestreamDecrypt({
  required String cameraName,
  required List<int> data,
  required BigInt expectedChunkNumber,
}) => RustLib.instance.api.crateApiLivestreamDecrypt(
  cameraName: cameraName,
  data: data,
  expectedChunkNumber: expectedChunkNumber,
);

Future<String> rustLibVersion() =>
    RustLib.instance.api.crateApiRustLibVersion();

Future<Uint8List> generateHeartbeatRequestConfigCommand({
  required String cameraName,
  required BigInt timestamp,
}) => RustLib.instance.api.crateApiGenerateHeartbeatRequestConfigCommand(
  cameraName: cameraName,
  timestamp: timestamp,
);

Future<String> processHeartbeatConfigResponse({
  required String cameraName,
  required List<int> configResponse,
  required BigInt expectedTimestamp,
}) => RustLib.instance.api.crateApiProcessHeartbeatConfigResponse(
  cameraName: cameraName,
  configResponse: configResponse,
  expectedTimestamp: expectedTimestamp,
);
